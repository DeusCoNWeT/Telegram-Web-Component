<!--
@license
@author Javier Caballero Abenza.
        Miguel Ortega Moreno. All rights reserved.

Example:

    <telegram-wc></telegram-wc>

@element telegram-wc
@demo demo/index.html
-->
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/iron-icon/iron-icon.html">
<link rel="import" href="bower_components/iron-icons/iron-icons.html">
<link rel="import" href="bower_components/iron-icons/av-icons.html">
<link rel="import" href="bower_components/paper-button/paper-button.html">
<link rel="import" href="bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="bower_components/paper-toolbar/paper-toolbar.html">
<link rel="import" href="bower_components/paper-input/paper-input.html">
<link rel="import" href="bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="bower_components/paper-styles/shadow.html">
<link rel="import" href="bower_components/paper-fab/paper-fab.html">



<script src="bower_components/moment/min/moment.min.js"></script>
<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
<script src="bower_components/telegram-api/dist/telegramApi.js"></script>
<dom-module id="telegram-wc">
  <template>
    <style is="custom-style" include="iron-flex iron-flex-alignment">
       :host {
        width: 400px;
        height: 400px;
        --telegram-background: #5682a3;
        overflow: hidden;
        position: relative;
        font: 14px/18px Tahoma, sans-serif, Arial, Helvetica;
        background-color: #e7ebf0;
        border: 1px solid #d2d2d2;
        border-radius: 5px;
        /* vertical layout*/
        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
        display: flex;
      }
      
      .container {
        overflow: auto;
      }
      
       :host[logged] {
        background-color: white;
      }
      
      .divisor {
        border: none;
        border-bottom: 1px solid #d2d2d2;
        margin: 0;
      }
      /* HEADER */
      
      paper-toolbar.toolbar {
        --paper-toolbar-background: var(--telegram-background);
        --paper-toolbar-title: {
          text-align: center;
          margin-left: auto;
          margin-right: auto;
          overflow: visible;
        }
      }
      
      .icon[icon="menu"] {
        width: 40px;
        height: 40px;
        margin-right: 25px;
      }
      
      paper-icon-button.icon {
        width: 40px;
        height: 40px;
      }
      /* CONTACTS VIEW */
      
      .contacts {
        padding: 6px 12px;
        background-color: white;
        cursor: pointer;
        box-sizing: border-box;
        position: relative;
      }
      
      .contacts:hover {
        background-color: #d2d2d2;
      }
      
      .contacts .name {
        margin: 2px 0;
      }
      
      .contacts .chatPreview {
        font-size: 12px;
        margin: 0;
        color: #8a8a8a;
        display: inline-block;
        width: 70%;
        white-space: nowrap;
        overflow: hidden !important;
        text-overflow: ellipsis;
        padding: 0 7px;
        box-sizing: border-box;
        max-width: 95%;
      }
      
      .displayName {
        width: calc(100% - 52px);
        /* profImg size + margin*/
      }
      
      .datechat {
        margin-left: 10px;
      }
      
      .profImg {
        height: 42px;
        width: 42px;
        border-radius: 50%;
        margin-right: 10px;
      }
      
      .profImg.small {
        height: 32px;
        width: 32px;
      }
      
      .emptyContacts {
        height: 100%;
      }
      
       ::-webkit-scrollbar-track {
        -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
        background-color: var(--paper-grey-200);
      }
      
       ::-webkit-scrollbar {
        width: 6px;
        background-color: var(--paper-grey-200);
      }
      
       ::-webkit-scrollbar-thumb {
        background-color: #42749b;
      }
      /* CHAT AREA */
      
      .chat {
        background: #ffffff;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      
      .chat >.content {
        background: rgba(173,205,227,1);
        background: -moz-radial-gradient(center, ellipse cover, rgba(173,205,227,1) 0%, rgba(134,174,204,1) 100%);
        background: -webkit-gradient(radial, center center, 0px, center center, 100%, color-stop(0%, rgba(173,205,227,1)), color-stop(100%, rgba(134,174,204,1)));
        background: -webkit-radial-gradient(center, ellipse cover, rgba(173,205,227,1) 0%, rgba(134,174,204,1) 100%);
        background: -o-radial-gradient(center, ellipse cover, rgba(173,205,227,1) 0%, rgba(134,174,204,1) 100%);
        background: -ms-radial-gradient(center, ellipse cover, rgba(173,205,227,1) 0%, rgba(134,174,204,1) 100%);
        background: radial-gradient(ellipse at center, rgba(173,205,227,1) 0%, rgba(134,174,204,1) 100%);
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#adcde3', endColorstr='#86aecc', GradientType=1 );
        background-size: 100% 100%;
        background-image: url('background.jpg');
      }
      
      .displayArea {
        padding: 10px;
        width: 100%;
        height: calc(100% - 106px);
        overflow-y: scroll;
        overflow-x: hidden;
        box-sizing: border-box;
      }
      
      .messageIn,
      .messageOut {
        border-radius: 5px;
        padding: 5px 8px 0 8px;
        margin-bottom: 10px;
        max-width: 50%;
        font: 13px Roboto, arial, sans-serif;
        position: relative;
        min-width: 60px;
      }
      
      .messageIn {
        float: left;
        margin-right: 50%;
        background: white;
      }
      
      .messageIn:before {
        content: "";
        position: absolute;
        width: 0;
        height: 0;
        border-bottom: 12px solid white;
        border-right: 21px solid transparent;
        border-left: 20px solid transparent;
        bottom: 0;
        left: -5px;
      }
      
      .messageOut {
        float: right;
        background-color: #DCF8C6;
        margin-left: 50%;
      }
      
      .messageOut:before {
        content: "";
        position: absolute;
        width: 0;
        height: 0;
        border-bottom: 5px solid #DCF8C6;
        border-right: 3px solid transparent;
        border-left: 19px solid transparent;
        bottom: 0;
        right: -3px;
      }
      
      .sender {
        margin:0;

      }
      .text {
        display: inline-block;
        word-break: break-all;
      }
      
      .date {
        font: 10px Roboto, arial, sans-serif;
        display: inherit;
        margin: 2px 4px 2px auto;
        text-align: right;
        color: #8a8a8a;
      }
      
      .date.lastmessage {
        margin-left: 10px;
      }
      
      .sendArea {
        width: 100%;
        height: auto;
        border-top: 1px solid #d2d2d2;
        background-color: white;
        max-width: 100%;
      }
      
      .input {
        font: 15px Roboto, arial, sans-serif;
        align-self: center;
        width: 100%;
        max-width: calc(100% - 36px);
      }
      
      .input>p {
        width: 100%;
        padding: 8px;
        max-width: 100%;
        overflow: auto;
        max-height: 100px;
        word-wrap: break-word;
        word-break: break-all;
        margin: 0;
      }
      
      .send {
        --paper-icon-button: {
          align-self: center;
          color: #42749b;
          width: 36px;
          height: 36px;
          padding: 8px;
        }
        ;
        --paper-icon-button-disabled: {
          color: #333;
        }
        ;
      }
      
      .status {
        font-size: 10px;
      }
      
      .groupicon {
        width: 20px;
        height: 20px;
        padding-bottom: 3px;
        margin-right: 2px;
      }
      
      .datemarker {
        clear: both;
      }
      
      .datemarker>span {
        background-color: #E1F2FB;
        color: #797979;
        padding: 5px 8px;
        border-radius: 4px;
        font-size: 12px;
      }
      
      .check {
        letter-spacing: -5px;
        color: green;
      }
      
      .check.sort {
        display: inline-block;
        width: 4px;
        line-height: 17px;
        color: #8a8a8a;
      }
      
      .unread {
        background-color: #5c9ccc;
        color: #fff;
        font-weight: 500;
        font-size: 12px !important;
        padding: 0px 5px;
        border-radius: 12px;
        min-width: 9px;
        text-align: center;
        display: -webkit-inline-flex;
        display: inline-flex;
        -webkit-align-items: center;
        align-items: center;
        -webkit-justify-content: center;
        justify-content: center;
        height: 19px;
        min-width: 19px;
        box-sizing: border-box;
        line-height: normal;
      }
      .loading {
        border-radius: 100%;
        border:2px solid white;
        width: 90px;height:90px
      }
      .createChat {
        position:absolute;
        bottom:10px;
        right:10px;
        --paper-fab-background: #5682a3;
        --paper-fab-iron-icon: {
          width:20px;
          height:20px;
        }
      }
      /* Login menus */
      
      .login {
        padding: 8px 16px;
        color: var(--paper-grey-700);
        font: 15px Roboto, arial, sans-serif;
        height: 100%;
        box-sizing: border-box;
        display: flex;
      }
      
      .loginMenu {
        padding: 0 18px 8px 18px;
        width: 100%;
        background-color: white;
      }
      
      .loginMenu span {
        display: inline-table;
      }
      
      .loginMenu input {
        width: 60%;
      }
      
      .inputContainer {
        position: relative;
      }
      
      .bold {
        font-weight: bold;
        text-transform: capitalize;
      }
      
      .subtitle {
        color: #999;
        margin: 15px 0 30px;
        font-size: 13px;
        line-height: 160%;
      }
      
      .code {
        margin: 0 5px;
        width: 50px;
        height: 30px;
      }
      
      paper-input {
        --paper-input-container-input: {
          font-size: 13px;
        }
        ;
        --paper-input-container: {
          padding: 0;
        }
      }
      
      .phoneContainer {
        margin-top: 30px;
        font-size: 13px;
      }
      
      .country-list {
        list-style: none;
        margin: 0;
        min-width: 100%;
        max-height: 100px;
        position: absolute;
        background-color: white;
        padding: 0;
        top: 50px;
        overflow: auto;
        z-index: 1000;
        color: #42749b;
        @apply(--shadow-elevation-6dp);
      }
      
      .country-list>li {
        padding: 8px 12px;
      }
      
      .country-list>li:hover {
        background-color: #f2f6fa;
      }
      
      .button {
        color: #42749b;
      }
      
      .loginMenu .button {
        margin-top: 12px;
        float: right;
      }
      
      .loginMenu .button.sendcode {
        float: none;
      }
      
      .requireCode {
        text-align: center;
      }
      
      .requireCode [name="phoneCode"] {
        margin-top: 60px;
      }
      
      .requireCode paper-button {
        margin-top: 18px;
      }
      /* Search bar */
      
      #contactSearch {
        --paper-input-container-focus-color: #d2d2d2;
        --paper-input-container-input-color: #d2d2d2;
      }
      /* ANIMATIONS */
      
      .animated {
        -webkit-animation-duration: 0.3s;
        animation-duration: 0.3s;
        -webkit-animation-fill-mode: both;
        animation-fill-mode: both;
      }
      
      @-webkit-keyframes fadeInRight {
        from {
          opacity: 0;
          -webkit-transform: translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0);
        }
        to {
          opacity: 1;
          -webkit-transform: none;
          transform: none;
        }
      }
      
      @keyframes fadeInRight {
        from {
          opacity: 0;
          -webkit-transform: translate3d(100%, 0, 0);
          transform: translate3d(100%, 0, 0);
        }
        to {
          opacity: 1;
          -webkit-transform: none;
          transform: none;
        }
      }
      
      .fadeInRight {
        -webkit-animation-name: fadeInRight;
        animation-name: fadeInRight;
      }
      /* LEFT MENU */
      
      .bar {
        bottom: 0;
        top: 0;
        position: absolute;
        z-index: 1000;
        width: 100%;
        height: 100%;
        /*-webkit-transition: fadeOut 0.3s ease-in;*/
        transition: left 0.3s ease-out;
        left: -100%;
        box-shadow: none;
        display: none;
      }
      
      .bar[show] {
        left: 0;
        /*-webkit-transition: fadeIn 0.3s ease-out;*/
        transition: left 0.3s ease-out, background-color 0.7s ease-out;
        background-color: rgba(0, 0, 0, 0.4);
      }
      
      .bar .avatar {
        border-radius: 50%;
        width: 60px;
        height: 60px;
      }
      
      .bar .userInfo {
        background-color: #42749b;
        text-align: left;
        width: 80%;
        padding: 10px 20px;
        box-sizing: border-box;
        position: relative;
      }
      
      .bar .userInfo p {
        font-size: 16px;
        text-transform: capitalize;
        color: #fefefe;
        margin: 10px 0 5px 0;
      }
      
      .bar .userInfo p.phone {
        font-size: 12px;
        color: #d2d2d2;
      }
      
      .bar .menuContent {
        padding: 10px 0px;
        position: relative;
        color: #333;
        background-color: var(--paper-grey-50);
        max-height: 100%;
        overflow-y: auto;
        width: 80%;
      }
      
      .closeMenu {
        position: absolute;
        top: 10px;
        right: 10px;
        display: inline-block;
        color: #d2d2d2;
      }
      
      .menuOptions {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }
      
      .menuOptions>li {
        padding: 10px;
        cursor: pointer;
      }
      
      .menuOptions>li:hover {
        background-color: rgba(210, 210, 210, 0.5);
      }
      
      .optionIcon {
        width: 20px;
        height: auto;
        margin-right: 10px;
      }
    </style>
<!-- Header -->
<paper-toolbar class="toolbar">
  <template is="dom-if" if="{{!logged}}">
    <img src="icon.png" class="icon"></img>
    <p>Telegram</p>
  </template>
  <template is="dom-if" if="{{logged}}">
    <paper-icon-button on-click="toggleMenu" class="icon" icon="menu"></paper-icon-button>
    <template is="dom-if" if="{{!searching}}">
      <p class="flex">Telegram</p>
    </template>
    <paper-input no-label-float class="flex self-center" hidden$="{{!searching}}" on-blur="checkCloseSearch" value="{{search_keywords}}"
      id="contactSearch"></paper-input>
    <template is="dom-if" if="{{!searching}}">
      <paper-icon-button icon="search" id="searchIcon" class="icon" on-click="searchContact"></paper-icon-button>
    </template>
  </template>
</paper-toolbar>
<div class="container flex">
  <!-- Login -->
  <template is="dom-if" if="{{!logged}}">
    <!-- Phone and code -->
    <div class="login" hidden="{{showCode}}">
      <div class="loginMenu vertical layout">
        <p class="bold">Register</p>
        <p class="subtitle">Please, select your country and introduce your phone number. You will receive a code of telegram app</p>
        <div class="inputContainer">
          <!-- Search country code -->
          <label for="country" class="subtitle">Country</label>
          <paper-input value="{{country}}" no-label-float focused="{{_openedSelector}}">
          </paper-input>
          <template is="dom-if" if="{{_openedSelector}}">
            <ul class="country-list" on-focus="_openSelector">
              <template is="dom-repeat" items="{{country_codes}}" filter="{{filterCountry(country)}}">
                <li on-mousedown="_selectCountry" tabindex="0">{{item.name}}</li>
              </template>
            </ul>
          </template>
          <!--  END search code-->
          <div class="phoneContainer horizontal layout ">
            <div>
              <label for="code" class="subtitle">Code</label>
              <paper-input name="code" value="{{countryCode}}" class="code" no-label-float>
                <div prefix>+</div>
              </paper-input>
            </div>
            <div class="flex">
              <label for="phonenumber" class="subtitle">Phone Number</label>
              <paper-input name="phonenumber" value="{{phone}}" class="phonenumber" id="phoneNumber" no-label-float tabindex="0"></paper-input>
            </div>
          </div>
          <paper-button on-click="sendCode" class="button">Send</paper-button>
        </div>
      </div>
    </div>
    <div class="login requireCode" hidden="{{!showCode}}">
      <div class="loginMenu">
        <p class="bold">+{{countryCode}} {{phone}}</p>
        <p class="subtitle flex">Enter the code you have received</p>
        <paper-input name="phoneCode" value="{{phoneCode}}" label="Insert your code here"></paper-input>
        <paper-button raised on-click="login" class="button sendcode">Send Code</paper-button>
      </div>
    </div>
  </template>
  <!-- Logged -->
  <template is="dom-if" if="{{logged}}">
    <!-- if Chat is closed -->
    <template is="dom-if" if="{{!selected}}">
      <template is="dom-if" if="{{!searching}}">
        <template is="dom-repeat" items="{{chats}}" id="chatscontainer" sort="_sortChatByLastMSG">
          <div class="contacts horizontal layout center" on-click="openChat">
            <img class="profImg" src="{{item.chat.photo}}">
            <div class="vertical layout displayName">
              <div class="horizontal layout">
                <template is="dom-if" if="{{item.chat.user.title}}">
                  <p class="name flex">
                    <iron-icon icon="supervisor-account" class="groupicon"></iron-icon>{{item.chat.user.title}}</p>
                </template>
                <template is="dom-if" if="{{item.chat.user.first_name}}">
                  <p class="name flex">{{item.chat.user.first_name}} {{item.chat.user.last_name}}</p>
                </template>
                <p class="date lastmessage">{{item.chat.last_message.date}}</p>
              </div>
              <div class="horizontal layout">
                <template is="dom-if" if="{{item.chat.last_message.mine}}">
                  <template is="dom-if" if="{{item.chat.last_message.sent}}">
                    <span class="check sort">✓</span>
                  </template>
                  <template is="dom-if" if="{{item.chat.last_message.read}}">
                    <span class="check sort">✓</span>
                  </template>
                </template>
                <p class="chatPreview flex">
                  <template is="dom-if" if="{{item.chat.last_message.isChat}}">
                    {{item.chat.last_message.from_user}}: 
                  </template>
                  {{item.chat.last_message.text}}
                  </p>
                <template is="dom-if" if="{{item.chat.messages_unread}}">
                  <span class="unread">{{item.chat.messages_unread}}</span>
                </template>
              </div>
            </div>
          </div>
          <hr class="divisor">
        </template>
        <template is="dom-if" if="{{!loading}}">
          <paper-fab class="createChat" on-click="searchContact" mini icon="create" title="open a new chat"></paper-fab>
        </template>
      </template>
      <template is="dom-if" if="{{searching}}">
        <template is="dom-repeat" items="{{contacts}}" filter="{{filterContact(search_keywords)}}" rendered-item-count="{{nContactsFound}}">
          <div class="contacts horizontal layout center" on-mousedown="loadContact">
            <template is="dom-if" if="{{item.image}}">
              <img class="profImg" src="{{item.image}}">
            </template>
            <template is="dom-if" if="{{!item.image}}">
              <img class="profImg" src="default.png">
            </template>
            <div class="vertical layout">
              <p>{{item.title}}{{item.first_name}} {{item.last_name}}</p>
            </div>
          </div>
          <hr class="divisor">
        </template>
        <template is="dom-if" if="{{showNoContacts}}">
          <div class="vertical layout center-center emptyContacts">
              <p class="title">No results</p>
          </div>
        </template>
      </template>
      <template is="dom-if" if="{{chats_empty}}">
        <!-- TODO loading info -->
        <div class="vertical layout center-center emptyContacts">
          <template is="dom-if" if="{{loading}}">
            <img class="loading" src="loading.gif"></img>
          </template>
          <template is="dom-if" if="{{!loading}}">
            <p class="title">No results</p>
          </template>
        </div>
      </template>
    </template>
    <!-- chat opened -->
    <template is="dom-if" if="{{user_selected}}">
      <div id="chatContainer" class="chat animated fadeInRight vertical layout">
        <paper-toolbar class="toolbar">
          <paper-icon-button on-click="closeChat" class="icon" icon="arrow-back"></paper-icon-button>
          <img class="profImg small" src="{{user_selected.photo}}">
          <div class="vertical layout">
            <template is="dom-if" if="{{user_selected.first_name}}">
              <span>{{user_selected.first_name}} {{user_selected.last_name}}</span>
            </template>
            <template is="dom-if" if="{{user_selected.title}}">
              <span><iron-icon icon="supervisor-account" class="groupicon"></iron-icon>{{user_selected.title}}</span>
            </template>
            <span class="status">{{_getStatus(user_selected.status)}}</span>
          </div>
        </paper-toolbar>
        <div class="content vertical layout flex">
          <div class="displayArea flex" id="displayArea">
            <template is="dom-repeat" items="[[user_selected.chat_messages]]" id="chatMessages">
              <template is="dom-if" if="{{item.mine}}">
                <template is="dom-if" if="{{showDateMarker(index, user_selected.chat_messages)}}">
                  <div class="datemarker vertical layout center-center">
                    <span>{{_getDate(item)}}</span>
                  </div>
                </template>
                <div class="messageOut vertical layout">
                  <span class="text">{{item.text}}</span>
                  <div class="date">
                    {{item.date}}
                    <template is="dom-if" if="{{item.sent}}">
                      <span class="check">✓</span>
                    </template>
                    <template is="dom-if" if="{{item.read}}">
                      <span class="check">✓</span>
                    </template>
                  </div>
                </div>
              </template>
              <template is="dom-if" if="{{!item.mine}}">
                <div class="messageIn">
                  <template is="dom-if" if="{{item.isChat}}">
                    <p class="sender" style$="color: {{item.user_color}}">{{item.from_user}}</p>
                  </template>
                  <span class="text">{{item.text}}</span>
                  <div class="date">
                    {{item.date}}
                  </div>
                </div>
              </template>
            </template>
          </div>
          <div class="sendArea horizontal layout">
            <div class="input flex horizontal layout">
              <p contenteditable="true" data-placeholder$="{{text_message==placeholder}}" class="flex" on-focus="removePlaceholder" on-blur="checkPlaceholder"
                on-keypress="updateTextMessage">{{placeholder}}</p>
            </div>
            <paper-icon-button icon="send" class="send" disabled="[[disable_send]]" on-click="sendMSG"></paper-icon-button>
          </div>
        </div>
      </div>
    </template>
    <div show$="{{menu_open}}" class="bar vertical layout" id="bar">
      <div class="userInfo">
        <img src="{{user.image}}" class="avatar">
        <p>{{user.first_name}}</p>
        <p class="phone">{{user.phone}}</p>
        <paper-icon-button class="closeMenu" on-click="toggleMenu" icon="arrow-back"></paper-icon-button>
      </div>
      <div class="menuContent flex">
        <ul class="menuOptions">
          <li on-click="logout">
            <iron-icon class="optionIcon" icon="exit-to-app"></iron-icon>
            <span>Logout</span>
          </li>
        </ul>
      </div>
    </div>
  </template>
</div>
</template>
</dom-module>
<script>
  Polymer({

    is: 'telegram-wc',

    properties: {
      loading: {
        type:Boolean,
        value:true
      },
      logged: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },

      showCode: {
        type: Boolean,
        value: false
      },

      searching: {
        type: Boolean,
        value: false
      },

      search_keywords: {
        type: String,
        value: ''
      },

      app: {
        type: Object,
        value: {
          id: 82261,
          hash: 'bb8cba71451932da9b62b7542ae27da2',
          version: '1.0.0'
        }
      },

      server: {
        type: Object,
        value: {
          test: [{
            id: 1,
            host: '149.154.175.10',
            port: 80
          }, {
            id: 2,
            host: '149.154.167.40',
            port: 80
          }, {
            id: 3,
            host: '149.154.175.117',
            port: 80
          }],
          production: [{
            id: 1,
            host: '149.154.175.50',
            port: 80
          }, {
            id: 2,
            host: '149.154.167.51',
            port: 80
          }, {
            id: 3,
            host: '149.154.175.100',
            port: 80
          }, {
            id: 4,
            host: '149.154.167.91',
            port: 80
          }, {
            id: 5,
            host: '149.154.171.5',
            port: 80
          }]
        },
      },
      chats: {
        type: Array,
        value: function () {
          return [];
        },
        notify: true,
        observe: true
      },
      chats_empty: {
        type: Boolean,
        computed: '_checkEmpty(chats.length)'
      },
      selected: {
        type: Boolean,
        value: false
      },
      text_message: {
        type: String,
        value: '',
        notify: true
      },
      placeholder: {
        type: String,
        value: 'Message'
      },
      disable_send: {
        type: Boolean,
        computed: '_isTextMessageEmpty(text_message)'
      },
      nContactsFound: {
        type: Boolean,
        observer: '_checkNContactsFound'
      },
      showNoContacts: {
        type: Boolean,
        value: true
      },
      _isPlaceholder: {
        type: Boolean,
        value: true
      },
      user_selected: {
        type: Object,
        notify: true
      },
      menu_open: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true
      }
    },
    observers: ['_renderChats(user_selected.chat_messages.length)'],
    // Observers
    _checkEmpty: function (chats) {
      return chats === 0;
    },
    _isTextMessageEmpty: function (message) {
      return !message;
    },
    _checkNContactsFound: function (newValue, oldValue) {
      this.set('showNoContacts', newValue == 0);
    },
    _renderChats: function () {
      if (this.$$('#chatMessages')) this.$$('#chatMessages').render();
    },
    //Component lifecycle
    attached: function () {
      var _self = this;
      var url = this.resolveUrl('code.json');
      $.get(url, function (data) {
        _self.set('country_codes', data);
      });
      telegramApi.setConfig({
        app: this.app,
        server: this.server,
      });
      // Extend telegram api
      telegramApi.getPhoto = function (type, photo) {
        var location = {
          _: "inputFileLocation",
          local_id: photo.local_id,
          secret: photo.secret,
          volume_id: photo.volume_id
        };
        var params = {
          dcID: photo.dc_id,
          fileDownload: true,
          singleInRequest: window.safari !== undefined,
          createNetworker: true
        };

        return telegramApi.invokeApi('upload.getFile', {
          location: location,
          offset: 0,
          limit: 524288
        }, params).then(function (result) {
          switch (type) {
            case 'byteArray':
              return result.bytes;
            case 'base64':
              return "data:image/jpeg;base64," + btoa(String.fromCharCode.apply(null, result.bytes));
            case 'blob':
              return new Blob([result.bytes], {
                type: 'image/jpeg'
              });
            default:
              return result.bytes;
          }
        });
      }
      this.getUser();
      var that = this;
      // set user status == online
            
      var that = this;
      this._visibilityInterval = window.setInterval(function(){
        var current_visibility = document.visibilityState;
        if (that._visibility !== current_visibility){
          var offline = document.visibilityState == 'visible'? false:true;
          console.info('Esta offline? : ', offline);
          that.setStatus(offline);
        }
        that._visibility = document.visibilityState;
      },1000)

      // $(window).on('focus',function(){
      //   that.setStatus(false);
      //   console.info('El usuario esta online porque la ventana está activa');
      // });
      // $(window).on('blur',function(){
      //   that.setStatus(true);
      //   console.info('El usuario esta offline');
      // });
    },

    dettached: function () {
      this.logout();
      window.clearInterval(this._visibilityInterval);
    },

    //Component behaviour

    /*------------------------------------Authentication----------------------------*/

    login: function () {
      if (this.registered) this.signIn();
      else this.signUp();
    },

    logout: function () {
      telegramApi.logOut();
      this.logged = false;
      this.showCode = false;
      this.set('chats', []);
      this.chat = null;
      this.user = null;
    },

    sendCode: function () {
      if (!this.phone || !this.countryCode) return;

      var me = this;
      telegramApi.sendCode(this.countryCode + this.phone).then(
        function (sent_code) {
          me.codeHash = sent_code.phone_code_hash;
          me.registered = sent_code.phone_registered;
          me.showCode = true;
        },
        function (error) {

        }
      );
    },

    signIn: function () {
      if (!this.phone || !this.codeHash || !this.phoneCode || !this.countryCode) return;

      var me = this;
      telegramApi.signIn((this.countryCode + this.phone), this.codeHash, this.phoneCode).then(
        function (response) {
          // ls
          me.getUser();
        }
      );
    },

    signUp: function () {
      if (!this.phone || !this.codeHash || !this.phoneCode || !this.countryCode) return;

      var me = this;
      telegramApi.signUp((this.countryCode + this.phone), this.codeHash, this.phoneCode, this.user.firstname,
        this.user.lastname).then(
        function (response) {
          // Sign up complete
          this.getUser();
        }
        );
    },

    /*--------------------------------------User info-------------------------------------*/

    getUser: function () {
      var me = this;
      telegramApi.getUserInfo().then(
        function (user) {
          if (user.id) {
            //Logged
            me.set('user', user);
            var phone = '+' + user.phone;
            phone = phone.match(/.{1,3}/g).join(' ')
            me.set('user.phone', phone);
            me.logged = true;
            me.getContacts();
            me.getDialogs();
            me.subscribe(user.id);

            var photo = user.photo.photo_small;
            telegramApi.getPhoto('base64', photo).then(
              function (result) {
                me.set('user.image', result);
              }
            );
          } else {
            me.loading = false;
          }
        }
      );
    },

    getContacts: function () {
      var me = this;
      telegramApi.invokeApi('contacts.getContacts', {}).then(
        function (response) {
          // sort contacts by first name
          me.set('contacts', response.users.sort(function (contact1, contact2) {
            // avoid space
            var first_name1 = contact1.first_name.replace(" ", "");
            var first_name2 = contact2.first_name.replace(" ", "");

            if (first_name1 < first_name2) return -1;
            if (first_name1 > first_name2) return 1;
            return 0;
          }));
          for (var i = me.contacts.length - 1; i >= 0; i--) {
            me.getPhotoContact(me.contacts[i]);
          };
        }
      );
    },

    /* getDialogs(): 
        Obtains the user recent dialogs 
        and subscribes to receive notifications
    */
    getDialogs: function () {
      var me = this;
      this.loading = true;
      telegramApi.getDialogs().then(
        function (response) {
          me.set('data', response.result);
          me.set('chats', []);
          var dialogs = response.result.dialogs;
          for (var i = 0; i < dialogs.length; i++) {
            // add to chats
            me.initializeChat(dialogs[i].peer);
            // subscribe modifications
            //me.subscribe(dialogs[i].peer);
          };

        }
      );
    },
    getChatIndexById: function (id) {
      var found = false;
      var index = -1;
      for (var i = 0; i < this.chats.length && !found; i++) {
        var chat_id = this.chats[i].chat.user.id;
        if (chat_id == id) {
          found = true;
          index = i;
        }
      }
      return index;
    },
    getContactIndexById: function (id) {
      var found = false;
      var index = -1;
      for (var i = 0; i < this.contacts.length && !found; i++) {
        var chat_id = this.contacts[i].id;
        if (chat_id == id) {
          found = true;
          index = i;
        }
      }
      return index;
    },
    _getStatus: function (status) {
      var current_status = '';
      if (status) {
        if (status._ == 'userStatusOnline') {
          current_status = "Connected";
        } else if (status._ == 'userStatusRecently') {
          current_status = "last seen recently"
        } else {
          var time = status.was_online * 1000;
          var dif = new Date() - time;
          if (dif < 24 * 60 * 60 * 1000) {
            current_status = "last seen " + moment(time).fromNow();
          } else {
            current_status = "last seen " + moment(time).format('D MMM. YYYY');
          }
        }
      }
      return current_status;
    },
    getPhoto: function (chat, peer) {
      return new Promise(function (resolve, reject) {
        if (!chat.user.photo || chat.user.photo._ == "chatPhotoEmpty") {
          chat.photo = this.resolveUrl('default.png');
          resolve({
            chat: chat,
            peer: peer
          });
          return;
        }

        var photo = chat.user.photo.photo_small;

        var me = this;
        telegramApi.getPhoto('base64', photo).then(
          function (result) {
            chat.photo = result;

            resolve({
              chat: chat,
              peer: peer
            });
          },
          function (error) {
            chat.photo = me.resolveUrl('default.png');
            resolve({
              chat: chat,
              peer: peer
            });
          }
        );
      }.bind(this));
    },

    getPhotoContact: function (user) {
      if (!user.photo) return;

      var photo = user.photo.photo_small;

      var me = this;
      telegramApi.getPhoto('base64', photo).then(
        function (result) {
          user.image = result;
        }
      );
    },
    /*
     * 
     */
    setStatus: function(offline){
      telegramApi.invokeApi('account.updateStatus',{offline:offline});
    },
    /*----------------------------------Load component--------------------------------*/

    initializeChat: function (peer) {
      /* Object stored on array 'chats' show on sidebar:
        {
          - Chat:
              - chat_messages[] (chat history)
              - photo (String type image/jpeg)
              - user (user talking with)
              - participants (if group)
          - Peer:
              - _ (type of peer: peerUser, peerChannel, peerChat)
              - id (user_id, channel_id, chat_id)
        }
      */
      var chat = {};
      chat.user = this.searchUser(peer);
      var that = this;
      if (chat.user.first_name || chat.user.title) {
        this.getPhoto(chat, peer).then(function (chat) {
          // take chat messages
          that.getHistoryUser(chat.chat.user).then(function (response) {
            chat.chat.chat_messages = that.getMSGs(response.messages, response.users);
            chat.chat.chat_messages.reverse();
            chat.chat.messages_unread = that._checkMessagesUnread(chat.chat.chat_messages, chat.chat.user
              .id);
            // if group, add participants
            if (response.users.length > 0) {
              chat.participants = response.users;
            }
            if (response.messages.length > 0) {
              chat.chat.last_message = chat.chat.chat_messages[chat.chat.chat_messages.length - 1];
            }
            that.push('chats', chat);
            that.loading = false;
          },
            function (error) {
              console.err(error);
              this.push('chats', chat);
              that.loading = false;
            })
        });
      }
    },

    getId: function (peer) {
      switch (peer._) {
        case 'peerUser':
          return peer.user_id;
          break
        case 'peerChannel':
          return peer.channel_id;
          break
        case 'peerChat':
          return peer.chat_id;
          break
      }
    },

    searchUser: function (peer) {
      var id = this.getId(peer);
      var found = false;
      for (var i = this.data.chats.length - 1; i >= 0 && !found; i--) {
        if (this.data.chats[i].id == id) {
          found = true;
          return this.data.chats[i]
        }
      }
      for (var i = this.data.users.length - 1; i >= 0 && !found; i--) {
        if (this.data.users[i].id == id) {
          found = true;
          return this.data.users[i];
        }
      };
    },
    getUserName: function (id) {
      var user = "";
      var found = false;

      for (var i = 0; i < this.contacts.length && !found; i++) {
        if (this.contacts[i].id == id) {
          user = this.contacts[i].first_name;
          found = true;
        }
      }

      return user;
    },

    /*---------------------------------Search methods-------------------------------*/

    searchContact: function () {
      this.searching = true;
      this.$$('#contactSearch').focus();
    },
    filterContact: function (keyword) {
      if (!keyword) {
        return null;
      } else {
        keyword = keyword.toLowerCase();
        return function (contact) {
          contact.title = contact.title || '';
          contact.first_name = contact.first_name || ' ';
          contact.last_name = contact.last_name || '';
          var full_name = (contact.title + ' ' + contact.first_name + ' ' + contact.last_name).toLowerCase();

          return (full_name.indexOf(keyword) != -1);
        };
      }
    },
    checkCloseSearch: function (e) {
      var isInput = e.currentTarget === this.$$('#contactSearch') && !e.detail;
      if (!this.search_keywords && !isInput) {
        this.searching = false;
      }
    },
    /*------------------------------------Load chat---------------------------------*/

    loadContact: function (e) {
      this.searching = false;
      this.search_keywords = '';
      var user = e.model.item;
      var exists = false;
      for (var i = this.chats.length - 1; i >= 0 && !exists; i--) {
        //If it exists
        if (this.chats[i].chat.user.id == user.id) {
          exists = true;
          var fakeEvent = {
            model: {
              item: this.chats[i],
              index: i
            }
          };
          this.openChat(fakeEvent);
        }
      }
      if (!exists) {
        var chat = {
          chat_messages: [],
          user: user,
          photo: user.image || this.resolveUrl('default.png')
        };
        var peer = {
          _: 'peerUser',
          user_id: user.id
        };
        this.push('chats', {
          chat: chat,
          peer: peer
        });
        // //Set selected style

        var fakeEvent = {
          model: {
            item: {
              chat: chat,
              peer: peer
            },
            index: this.chats.length - 1
          }
        };
        this.openChat(fakeEvent);
      }
    },
    /*----------------------------------Comunication methods-----------------------------*/

    sendMSG: function (text) {
      var text = text || this.text_message;
      if (!text) return null;

      var me = this;
      telegramApi.sendMessage(this.getId(this.user_selected.peer), text).then(
        function (response) {
          var message = me.parseMSG(response);
          message.mine = true;
          message.text = text;

          //me.push('user_selected.chat_messages', message);
          me.addMSG(me.getId(me.user_selected.peer), message);
          me.fixBottom();
        }
      );
    },

    subscribe: function (peer) {
      var id = this.getId(peer);
      console.info('Subscrito al peer: ', peer);
      var me = this;
      telegramApi.subscribe(id,
        function (response) {
          if (me[response._]) {
            me[response._](response);
          } else {
            console.info('Handler doesnt found ' + response._);
          }
        });
    },
    addMSG: function (id, message) {
      var chat_index = this.getChatIndexById(id);
      // If its a new chat
      if (chat_index == -1) {
        // look for contact with same ID
        var newChatIndex = this.getContactIndexById(id);
        if (newChatIndex === -1) {
          console.error('User doesnt found in chats and contacs list');
          return;
        }
        // add user to chats 
        var user = this.contacts[newChatIndex]
        var chat = {
          chat_messages: [message],
          user: user,
          photo: user.image || this.resolveUrl('default.png'),
          last_message: message.text,
          messages_unread: message.mine ? 0 : 1
        };
        var peer = {
          _: 'peerUser',
          user_id: user.id
        };
        this.push('chats', {
          chat: chat,
          peer: peer
        });



      } else {
        // assign color
        if (message.isChat){
          // TODO el id que le paso es el del chat no el del mensaje, hay que corregirlo
          message.user_color = this._getRandomColor(message._base.from_id, this.chats[chat_index].participants);
        }
        this.push('chats.' + chat_index + '.chat.chat_messages', message);

        this.chats[chat_index].chat.last_message = message;
        this.notifyPath('chats.' + chat_index + '.chat.last_message', message);

        if (this.user_selected && this.user_selected.id == id){
          this.notifyPath('user_selected.chat_messages',this.chats[chat_index].chat.chat_messages);
        }
        // Update Number chats unread
        if ((!this.user_selected || this.user_selected.id != id) && !message.mine) {
          var unread = this.chats[chat_index].chat.messages_unread ? this.chats[chat_index].chat.messages_unread +
            1 : 1;
          this.chats[chat_index].chat.messages_unread = unread;
          this.notifyPath('chats.' + chat_index + '.chat.messages_unread', this.chats[chat_index].chat.messages_unread);
        } else {
          // Notify new chat
        }
        // force render in order to re-sort chats
        this.$$('#chatscontainer').render();
        if (this.$$('#chatMessages')) {
          this.$$('#chatMessages').render();
          this.fixBottom();
        }
        // Update Number chats unread
      }


    },
    updateMSG: function (user_id, msg_id) {
      var chat_id = this.searchChatByUserId(user_id);
      if (chat_id == -1) {
        console.error('No se encuentra el chat al actualizar');
        return;
      }
      var end = false;
      var length = this.chats[chat_id].chat.chat_messages.length;
      for (var i = 0; i < length; i++) {
        var chat = this.chats[chat_id].chat.chat_messages[i];
        if (chat.mine && !chat.read) {
          this.chats[chat_id].chat.chat_messages[i].read = true;
          this.notifyPath('chats.' + chat_id + '.chat.chat_messages.' + i + '.read', this.chats[chat_id].chat.chat_messages[
            i].read);

          this.chats[chat_id].chat.chat_messages[i]._base.pFlags.unread = false;
          this.notifyPath('chats.' + chat_id + '.chat.chat_messages.' + i + '._base.pFlags.unread', this.chats[
            chat_id].chat.chat_messages[i]._base.pFlags.unread);

          if (this.user_selected && this.user_selected.id == user_id) {
            this.user_selected.chat_messages[i].read = true;
            this.notifyPath('user_selected.chat_messages.' + i + '.read', this.user_selected.chat_messages[i].read);
          }

          if (i == length - 1) {
            this.chats[chat_id].chat.last_message.read = true;
            this.notifyPath('chats.' + chat_id + '.chat.last_message.read', this.chats[chat_id].chat.last_message
              .read);
          }
        } else if (chat.read) {
          end = true;
        }
      }
      return i;
    },
    /*-------------------------------Refresh chat history-------------------------------*/

    getHistoryUser: function (user, cb) {
      return new Promise(function (resolve, reject) {
        if (user._ == 'user') {
          var type = 'user';
        } else {
          var type = 'chat';
        }
        var me = this;
        telegramApi.getHistory({
          id: user.id,
          take: 50,
          type: type
        }).then(resolve, reject);
      });
    },
    getMSGs: function (msgs, users) {
      var messages = [];
      msgs.forEach(function (message) {
        var msg = this.parseMSG(message);
        var id = message.from_id;
        if (msg.isChat && users.length > 0){
          msg.user_color = this._getRandomColor(id, users);
        }
        messages.push(msg);
      }.bind(this));
      return messages;
    },
    removeChat: function () {
      // stop pulling
      this.selected = false;
      this.set('chat_messages', []);
      this.set('user_selected', undefined);
    },

    refreshStatus: function (user_id, status) {
      var that = this;
      // chats
      this.chats.forEach(function (chat, index) {
        var user = chat.chat.user;
        if (user.id == user_id) {
          that.set('chats.' + index + '.chat.user.status', status);
        }
      });
      // contact
      this.contacts.forEach(function (contact, index) {
        if (contact.id == user_id) {
          that.set('contacts.' + index + '.status', status);
        }
      });
      // user_selected
      if (this.user_selected && this.user_selected.id == user_id) {
        that.set('user_selected.status', status);
      }
    },

    readMessages: function(id, max_id){
      var chat_index = this.getChatIndexById(id);

      var length = this.chats[chat_index].chat.chat_messages.length;
      
      var chat = this.chats[chat_index].chat;
      var end = false;
      for (var i =0; i < length && !end; i++){
        var message = chat.chat_messages[i]
        if (!message.mine && !message.read && message.id !== max_id){
          this.chats[chat_index].chat.chat_messages[i].read = true;
          this.notifyPath('chats.' + chat_index + '.chat.chat_messages.' + i+'.read', true);
        } else if (message.id === max_id){
          this.chats[chat_index].chat.chat_messages[i].read = true;
          this.notifyPath('chats.' + chat_index + '.chat.chat_messages.' + i+'.read', true);
          end = true;
        }
      }
      // Update unread messags
      var id = this.chats[chat_index].chat.user.id;
      var unread = this._checkMessagesUnread(this.chats[chat_index].chat.chat_messages, id);
      
      this.chats[chat_index].chat.messages_unread = unread;
      this.notifyPath('chats.' + chat_index + '.chat.messages_unread', unread);
    },
    /*----------------------------------Display methods----------------------------------*/

    fixBottom: function () {
      //Fix scroll bar bottom
      var container = this.$$('#displayArea');
      if (container) {
        container.scrollTop = container.scrollHeight;
        if (container.scrollTop != container.scrollHeight) {
          var promise = new Promise(function (resolve, reject) {
            window.setTimeout(
              function () {
                resolve();
              }, 100);
          });
          /* DELAY */
          var me = this;
          promise.then(function () {
            container.scrollTop = container.scrollHeight;
          });
        }
      }
    },


    parseMSG: function (msg) {

      if (!msg) return;

      //Check outbound or inbound message
      message = {};
      var id = msg.from_id || msg.user_id || msg.chat_id;
      if (id == this.user.id) {
        message.mine = true;
      } else {
        message.mine = false;
      }

      //Text
      message.text = msg.message;

      //Parse date
      var date = new Date(msg.date * 1000);
      message.date = moment(date).format('HH:mm');
      message.timestamp = date.getTime();

      // parse sent
      message.sent = msg.pFlags.out ? true : false;
      message.read = !msg.pFlags.unread ? true : false
      //Set id
      message.id = msg.id;

      // check if its a chat message
      message.isChat = (msg.to_id && msg.to_id.chat_id) || msg.chat_id? true : false;
      if (message.isChat) {
        message.from_user = this.getUserName(id);        
      }

      // if its a media file say it
      message._base = msg;
      if (msg.media){
        message.text = "[MEDIA it doesn't implemented] " + message.text;
      }
      return message;

    },
    openChat: function (e) {
      var id = e.model.item.chat.user.id;
      var index = this.getChatIndexById(id);
      this.set('user_selected', e.model.item.chat.user);
      this.set('user_selected._index', e.model.index);
      this.set('user_selected.photo', e.model.item.chat.photo);
      this.set('user_selected.peer', e.model.item.peer);
      this.set('user_selected.chat_messages', e.model.item.chat.chat_messages || []);
     
      this.chats[index].chat.messages_unread = 0;
      this.notifyPath('chats.' + index + '.chat.messages_unread', 0);
     
      this.selected = true;
      var that = this;
      window.setTimeout(function () {
        that.fixBottom();
      }, 100);

    },
    closeChat: function () {
      this.removeChat();
    },
    showDateMarker: function (index, list) {
      if (index == 0) {
        return true;
      }
      if (index >= list.length) {
        return true;
      }
      var current_message = new Date(list[index].timestamp);
      var previus_message = new Date(list[index - 1].timestamp);

      if (current_message.getDay() == previus_message.getDay() &&
        current_message.getMonth() == previus_message.getMonth() &&
        current_message.getYear() == previus_message.getYear()) {
        return false;
      } else {
        return true;
      }
    },
    /*--------------------------------List country callback-----------------------------*/
    _openSelector: function () {
      this._openedSelector = true;
    },
    _selectCountry: function (e) {
      var item = e.model.item;
      this.country = item.name;
      this.countryCode = item.number;
      this._openedSelector = false;
      this.$$('#phoneNumber').$.input.focus();
    },

    // Filter country
    filterCountry: function (country) {
      if (!country) {
        return null;
      }
      return function (item) {
        var name = item.name.toLowerCase()
        country = country.toLowerCase();
        return name.indexOf(country) != -1;
      }
    },
    /*----------------------------------Input text methods ----------------------------------*/
    removePlaceholder: function (e) {
      var target = e.currentTarget;
      var text = target.innerHTML;
      target.innerHTML = text === this.placeholder ? '' : text;
      this._isPlaceholder = false;
    },
    checkPlaceholder: function (e) {
      var target = e.currentTarget;
      target.innerHTML = target.innerHTML || this.placeholder;
      this._isPlaceholder = target.innerHTML == this.placeholder;
    },

    updateTextMessage: function (e) {
      var code = e.keyCode;
      var text = e.currentTarget.innerHTML + String.fromCharCode(code);
      this.text_message = text;
      if (code === 13) {
        // send message
        // Prevent navigator add <div>br</div>
        e.preventDefault();
        this.sendMSG(this.text_message);
        e.currentTarget.innerHTML = '';
        // e.currentTarget.blur();
        this.text_message = '';
      }
    },

    /*---------------------------------- Left menu ----------------------------------*/
    toggleMenu: function (e) {
      this.menu_open = !this.menu_open;
    },


    /*------------------------------ Auxiliar functions-------------------------------*/
    _sortChatByLastMSG: function (chat1, chat2) {
      var msg1_time = chat1.chat.last_message ? chat1.chat.last_message.timestamp : -1;
      var msg2_time = chat2.chat.last_message ? chat2.chat.last_message.timestamp : -1;

      return msg2_time - msg1_time;

    },
    searchChatByMsgId: function (message_id) {
      var found = false;
      var index = -1;
      for (var i = 0; i < this.chats.length && !found; i++) {
        var messages = this.chats[i].chat.chat_messages;
        if (messages && messages.length > 0 && messages[0].id == message_id) {
          found = true;
          index = i;
        }
      }
      return index;
    },
    searchChatByUserId: function (user_id) {
      var found = false;
      var index = -1;
      for (var i = 0; i < this.chats.length && !found; i++) {
        var id = this.chats[i].chat.user.id;
        if (id == user_id) {
          found = true;
          index = i;
        }
      }
      return index;
    },
    _getDate: function (item) {
      var date = item.timestamp;
      return moment(date).calendar(null, {
        sameDay: '[Today]',
        nextDay: '[Tomorrow]',
        lastDay: '[Yesterday]',
        lastWeek: 'MMM DD, YYYY',
        sameElse: 'MMM DD, YYYY'
      });
    },
    _checkMessagesUnread: function (list_messages, id) {
      var count = 0;
      if (id !== this.user.id) {
        list_messages = list_messages || [];
        list_messages.forEach(function (message) {
          if (!message.read && !message.mine) {
            count += 1;
          }
        });
      }
      return count;
    },
    _getRandomColor: function (id, participants) {
      var color = ["#F44336", "#E91E63", "#9C27B0", "#673AB7", "#3F51B5", "#2196F3",
       "#03A9F4", "#00BCD4", "#009688", "#4CAF50", "#8BC34A", "#CDDC39","#FFEB3B",
       "#FFC107", "#FF9800", "FF5722", "#795548", "#607D8B"]

      var index = -1;
      for(var i =0; i<participants.length && index== -1;i++){
        if (participants[i].id == id){
          index = i;
        }
      }
      if (index == -1){
        console.error('ID doesnt found in participants list', id, participants);
        index =0;
      }
      return color[index]

    },
    /*------------------------------ subscribe handler -------------------------------*/
    updateShort: function (response) {
      // when status is updated
      if (response.update) {
        this.refreshStatus(response.update.user_id, response.update.status);
      } 
    },
    msgs_ack: function (response) {
      // Only say msgs_ack but msg_ids is empty
    },
    msg_container: function (response) {
      var messages = response.messages;
      messages.forEach(function(message){
        if (message.body){
          if (this[message.body._]) {
            this[message.body._](message.body);
          } else {
            console.info('Handler doesn\'t found ' + message.body._);
          }
        }

      }.bind(this))
    },
    // sent a message
    updateShortMessage: function (response) {
      // If its a message sent by my to me. Its already out
      if (response.user_id == this.user.id) {
        response.pFlags.out = response.pFlags.out || true;
      }
      // flag 1 message in from user_id
      // flag 3 message out to user_id from me
      if (response.flags == 1) {
        response.from_id = response.from_id || response.user_id;
      } else { // flag !== 1?
        response.from_id = this.user.id;
      }
      var msg = this.parseMSG(response);
      this.addMSG(response.user_id || response.chat_id, msg);
    },
    updateShortChatMessage: function (response) {
      var msg = this.parseMSG(response);
      this.addMSG(response.user_id || response.chat_id, msg);
    },
    updates: function (response) {
      var that = this;
      response.updates.forEach(function (update) {
        if (that[update._]) {
          that[update._](update);
        } else {
          console.info('TODO Implement hander for' + update._);
          console.info(update);
        }

      });
    },
    updateUserStatus: function (response) {
      this.refreshStatus(response.user_id, response.status);
    },
    updateNewMessage: function (response) {
      if (response.message._ !== "messageEmpty") {
        var msg = this.parseMSG(response.message);

        var id;
        if (msg.isChat){
          id = repsonse.message.to_id.chat_id;
        } else if (response.message.from_id == this.user.id){
          id = response.message.to_id.user_id;
        } else {
          id = response.message.from_id
        }
        this.addMSG(id, msg);
      } else {
        // Delete historial
        console.info('Historial deleted', response);
      }
    },
    updateDeleteMessages: function (response) {
      var index_chat = this.searchChatByMsgId(response.messages[0]);
      var removed = this.splice('chats', index_chat, 1);
    },
    rpc_result: function (response) { },
    updateReadHistoryOutbox: function (response) {
      var id = response.peer.user_id || response.peer.chat_id;
      this.updateMSG(id, response);
    },
    // other telegram session has read a message unread
    updateReadHistoryInbox: function (response) {
      var id = response.peer.chat_id || response.peer.user_id;
      this.readMessages(id, response.max_id);
    },

    // TODO implementar updateChatUserTyping pero depende de que marque la session como activa cuando veo el componente
    
    new_session_created: function(response){
    },
  });
</script>